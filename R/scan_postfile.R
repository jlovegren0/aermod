#' Scan POST file
#' 
#' Reads Fortran unformatted I/O POSTFILE and conver to matrix.
#' Hours are not written individually, nor are source groups
#' as they are saved as attributes of the matrix.
#'
#' The AERMOD user's guide (3-186--3-187) describes the format of the file as follows:
#'
#'   ``... the resulting unformatted file includes a constant-length record for each of
#'  the selected averaging periods calculated during the model run. The first variable of each record is
#'  an integer variable (4 bytes) containing the ending date (YYMMDDHH) for the averages on that
#'  record. The second variable for each record is an integer variable (4 bytes) for the number of hours
#'  in the averaging period. The third variable for each record is a character variable of length eight
#'  containing the source group ID. The remaining variables of each record contain the calculated
#'  average concentration values for all receptors, in the order in which they were defined in the input
#'  runstream.''
#'
#' 
#' The records themselves are delimited by 4 byte integers (at the start and end of each record)
#' giving the size (in bytes of the record). There is some predictability in the data:
#' As generated by AERMOD, all records have an equal
#' number of bytes. Additionally, the hours are numbered sequentially, without gaps, and
#' the source group and averaging time are the same for each record. Therefore, the only
#' information that needs to be stored at the record level is the ordered tuple of concentrations
#' at each receptor for the particular hour and source group. \code{scan_postfile} stores 
#' this information as a matrix, and stores the starting hour, averaging period, and source group name
#' as attributes of the matrix, rather than repeating the information with each row.
#' @name scan_postfile
#' @param f path to an unformatted Fortran I/O binary POST file generated by AERMOD.
#' @param ... arguments passed thru to \code{readBin}. Primary use is to specify endianness in case POST file was generated on a machine with different endianness from your own.
#' @return An impact matrix with attributes \code{srcgrp} and \code{hrbaseline} (first hour). The number of hours and number of receptors can be
#' accessed by calling the built-in \code{dim} function on the matrix.
#' @importFrom magrittr %>%
#' @importFrom magrittr %<>%
#' @export
scan_postfile <- function(f,...){
rewind <- function(fp) seek(fp,0)
fp <- file(f,open="rb",raw=TRUE)
on.exit(close(fp))
	reclen <- readBin(fp,what='integer',...)
	hr <- readBin(fp,what='integer',...)
	aveper <- readBin(fp,what='integer',...)
	srcgrp <- readBin(fp,what='raw',n=8,...) %>% rawToChar
	nc <- (reclen - 16) / 8
seek(fp,where=0,origin="end")
nbytes <- seek(fp)
rewind(fp)
nhrs <- nbytes / (reclen + 8)
container <- vector(mode="double",length= nhrs * nc )
for ( hh in 1:nhrs )
{
	seek(fp,where=20,origin="current")
	container[ ((hh-1) * nc + 1) : (hh*nc) ] <- readBin(fp,what='double',n=nc,...)
	seek(fp,where=4,origin="current")
}
res <- matrix( container , ncol = nc , byrow=TRUE)
attr(res,'srcgrp') <- stringr::str_trim(srcgrp)
attr(res,'hrbaseline') <- lubridate::ymd_h(stringr::str_glue('20{hr}')) - lubridate::hours(2)
return(res)
}
